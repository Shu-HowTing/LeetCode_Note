## 链表

![链表定义与存储方式](https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_definition.png)

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
```

- 链表的遍历

```py
cur = head
while cur:
    length += 1
    cur = cur.next
```

- [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```py
def reverseList_iterative(head):
    prev = None
    cur = head
    while curr:
        next_node = cur.next
        cur.next = prev
        prev = cur
        cur = next_node
    return prev


def reverseList_recursive(head):
    if not head or not head.next:
        return head
    new_head = reverseList_recursive(head.next)
    head.next.next = head
    head.next = None
    return new_head
```

- [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)

![](https://markdown-1258220306.cos.ap-shenzhen-fsi.myqcloud.com/img/202408252138302.png)

```py
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        dump_A = headA
        dump_B = headB
        while headA or headB:
            if headA == headB:
                return  headA
            headA = headA.next
            headB = headB.next  
            if not headA and not headB:
                return None
            if not headA:
                headA = dump_B
            if not headB:
                headB = dump_A
```

- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                fast = head
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                return fast
        return
```

参考： [快慢指针，清晰严谨的图示推导，附多语言实现](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/2832831/jian-ji-qing-xi-yan-jin-de-tu-shi-tui-da-nak2/)

- [面试题 02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

> **示例：**
> 
> **输入：** 1->2->3->4->5 和 *k* = 2
> **输出：** 4

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def kthToLast(self, head: ListNode, k: int) -> int:
        fast, slow = head, head
        while k and fast:
            fast = fast.next
            k -= 1
        while fast:
            slow = slow.next
            fast = fast.next
        return slow.val
```

- [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

> **示例 1：**
> 输入：head = [1,2,2,1]
> 输出：true

![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```py
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next:
            return True

        # 1. 找到中点
        # 2. 切开
        # 3. 后半部倒序
        # 4. 逐一比较铬元素是否相同
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        mid = slow.next

        pre = None
        while mid:
            tmp = mid.next
            mid.next = pre
            pre = mid
            mid = tmp


        right = pre
        while right:
            if head.val == right.val:
                head = head.next
                right = right.next
            else:
                return False
        return True
```

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

> 给你一个链表数组，每个链表都已经按升序排列。
> 
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution: 
    # 合并两个有序链表
    def merge2list(self, left, right):
        if not left:
            return right
        if not right:
            return left
        if left.val < right.val:
            left.next = self.merge2list(left.next, right)
            return left
        else:
            right.next = self.merge2list(left, right.next)
            return right


    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        # 归并排序第一步, 分而治之
        if not lists:
            return 
        if len(lists) == 1:
            return lists[0]
        mid = len(lists) // 2
        left = self.mergeKLists(lists[:mid])
        right = self.mergeKLists(lists[mid:])
        result = self.merge2list(left, right)
        return result
```