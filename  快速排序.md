## 快速排序 -- QuickSort

#### 思路

将序列分为两个子序列：$S = S_L + S_R$

- 规模更小
- 批次独立： $max(S_L) <= min(S_R)$

在子序列分别递归的排序之后，原序列必然有序

​                $sorted(S)  = sorted(S_L) + sorted(S_R)$

**难点：如何分**

#### 轴点:

$pivot:$左/右侧的元素，均布比它大/小

![](https://img-blog.csdn.net/20180904010743632?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDExNjA3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

已轴点为界，原序列的划分自然实现：

$[lo, hi) = [lo, mi)  + [mi] + (mi, hi)$

必要条件：轴点必然已经就位.

整体算法框架：

```python
def quicksort(nums):
    n = len(nums)
    _quicksort(nums, 0, n)

def _quicksort(nums, left, right):
    if left >= right:
        return 
    # pivot
    pivot_index = __partition(nums, left, right)
    _quicksort(nums, left, pivot_index)
    _quicksort(nums, pivot_index+1, right)
```

核心代码在于如何完成$pivot$元素的放置，即$\_\_partition()$函数

如图所示：

<img src="https://img-blog.csdn.net/20180904022507207?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDExNjA3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:67%;" />

```python
def __partition(nums, left, right):
    pivot = nums[left]
    j = left
    for i in range(left + 1, right):
        if nums[i] < pivot:
            j += 1
            nums[i], nums[j] = nums[j], nums[i]

    nums[left], nums[j] = nums[j], nums[left]
    return j
```

- **问题1：对于渐进有序的数组，效率不高**

我们知道，归并排序复杂度$O(nlogn)$中$logn$的原因是每次归并都是高度平衡的，即左右两支长度相等。平衡度越好，性能越接近logn。快排每次都从左边第一个数作为比较数，而对于渐进有序的数组来说，每次区分其实都是极其不平衡的（如下图），甚至会退化成$O(n^2)$.

<img src="https://img-blog.csdn.net/20180904023245480?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDExNjA3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:40%;" />

<img src="https://img-blog.csdn.net/20180904023400801?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDExNjA3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom:80%;" />

**改进方式：随机化基准数，得到随机普通快排**

平均意义上，对于任何数组（包括渐进有序数组），快排遇到最差情况的概率将大大降低。代码如下:

```python
def __partition(nums, left, right):
    rd_i = random.randint(left, right)
    arr[left], arr[rd_i] = arr[rd_i], arr[left]
    pivot = nums[left]
    j = left
    for i in range(left + 1, right):
        if nums[i] < pivot:
            j += 1
            nums[i], nums[j] = nums[j], nums[i]

    nums[left], nums[j] = nums[j], nums[left]
    return j
```

### 选取与中位数

**$K-selection:$** 在任意一组可比较大小的元素中，如何由小到大，找到次序为$k$的元素？(第k大元素)

**众数**

首先，让我们先来看看众数。

定义：如果一个数组元素中，某个元素出现的次数超过了一半以上，那么我们称这个元素为这组元素的众数。否则，众数不存在。

> 每次取出两个不同的数，剩下的数字中重复出现的数字肯定比其他数字多，将规模缩小化。如果每次删除两个不同的数（不管包括不包括最高频数），那么在剩余的数字里，原最高频数出现的频率一样超过了50%，不断重复这个过程，最后剩下的将全是同样的数字，即最高频数。此算法避免了排序，时间复杂度只有O(n)，空间复杂度为O(1)。

```python
def find_majority(nums):
    count = 0
    for num in nums:
        if count == 0:
            maj = num
        else:
            if maj == num:
                count += 1
            else:
                count -= 1
    return maj

if __name__ == '__main__':
    nums = [1, 2, 4, 2, 3, 2, 2]
    maj = find_majority(nums)
    count = 0
    for num in nums:
        if num == maj:
            count += 1
    if count > len(nums) // 2:
        return True
    else:
        return False       
```
