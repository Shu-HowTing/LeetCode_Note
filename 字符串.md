## 字符串

### 字符串匹配

#### 串

**字符串**

一般的，由n个字符构成的串记作：

$S = "a_0 a_1 ··· a_{n-1}"$ , 其中 $a_i$属于$\sum$, $0<=i<n$。$\sum$称之为字符表

**子串**

​                                  $ S.substr(i ,k) = S[i, i+k)$

**前缀**

​                                   $ prefix(S, k) = S.substr(0, k) = s[0,k]$

**后缀**

​                                   $suffix(S, k) = S.substr(n-k, k) = S[n-k, n)$

> 空串是任何字符串的子串，也是任何字符串的的前缀和后缀。

#### 匹配

$Patern\ Matching$

- $detection:$  P是否出现
- $ location：$ 首先在哪里出现
- $ counting：$ 一共出现几次
- $ enumeration：$ 各出现在哪里

#### 蛮力算法

```c
for (i = 0; i < n-m + 1; i++){
    for ( j = 0; j < m, j++)
        if (T[i + j] != p[j])
            break;
       if j>=m break;
}
return i
```

时间复杂度：$O(n·m)$

#### KMP算法

[实现原理](https://www.bilibili.com/video/BV1Px411z7Yo?t=410)

```python
'''
KMP算法
'''
def KMP(text, pattern):
    n = len(text)
    m = len(pattern)
    Next = gen_N(pattern)
    i, j = 0, 0
    while j < m and i < n:
        if text[i] == pattern[j] or j < 0:
            j += 1
            i += 1
        else:
            j = Next[j]
    print((i, j))
    return i - j

# 构造next向量，子串的最长公共前后缀
def gen_N(pattern):
    m = len(pattern)
    Next = [-1] * m
    j = 0
    t = Next[0]
    while j < m - 1:
        if t < 0 or pattern[j] == pattern[t]:
            t += 1
            j += 1
            Next[j] = t
        else:
            t = Next[t]
    return Next


if __name__ == "__main__":
    text = "abcbabad"
    pattern = "aba"
    # print(gen_N(pattern))
    print(KMP(text, pattern))
```

- [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

> 给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数*  。
> 
> 你可以对一个单词进行如下三种操作：
> 
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符

```bash
示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

```py
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m = len(word1)
        n = len(word2)
        dp = [[0 for i in range(n+1)]for j in range(m+1)]
        for i in range(1, m+1):
            dp[i][0] = dp[i-1][0] + 1
        for j in range(1, n+1):
            dp[0][j] = dp[0][j-1] + 1
        for i in range(1, m+1):
            for j in range(1, n+1):
                if word1[i-1] == word2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
        return dp[m][n]
```
