## 链表

**根据是否修改数据结构，所有的操作大概分为两类：**

- 静态：仅读取，数据的内容和组成一般不变：get、search
- 动态：需写入，数据结构的局部或整体将改变

与操作方式类似，数据元素的存储与组织方式也分为两种：

- 静态：数据空间整体创建或销毁
  
  ​            数据元素的<u>物理存储次序</u>与其<u>逻辑次序</u>严格一致
  
  ​            可支持高效的静态操作
  
  ​            比如向量，元素的地址与其逻辑次序线性对应

- 动态：为各元素动态的分配和回收的物理空间
  
  ​          逻辑上相邻的元素记录彼此的地址，在逻辑上形成一个整体
  
  ​         可以支持高效的动态操作，比如链表

## 词典

散列表：

hash函数： hash(key) = key % M

### 散列函数：

hash：S-->A

**性质**

- 确定性：同一个关键码总是被映射为同一个地址
- 快速：O(1)
- 满射：尽可能充满整个散列空间
- 均匀：关键码映射到散列表各位置的概率尽量接近，避免聚集(clustering)现象

**常用的散列函数**

- 除余法
  
   hash(key) = key % M
  
  M通常取素数

- MAD法
  
  除余法的缺陷：
  
  - 不动点：hash(0) = 0
  - 相邻的关键码的散列地址必然也是相邻
  
  MAD = multiplay add divide
  
  取M为素数，a>0, b>0, a % M ≠ 0
  
  hash(key) = (a * key + b) % M

- 总之，越是随机，越是没有规律，越好 

**Hashcode**

- 将关键码为非整数转换为整数的函数，如字符串

### 散列冲突

- 多槽位：multiple_slot
  
  独立链：linked-list chaining
  
  每个桶存放一个指针，冲突的词条组成列表
  
  优点：
  
  - 无需为每个桶预留多个槽位
  - 任意多次的冲突都可以解决
  - 删除擦欧总实现简单
  
  缺点：
  
  - 指针需要额外的空间
  - 节点需要动态申请
  - 空间分布未必连续，系统缓存几乎失效

- 开放地址--闭散列
  
  - 线性试探
  
  - 平方试探
    
    [Hash(key) + 1] % M
    
    [Hash(key) + 4] % M
    
    [Hash(key) + 9] % M
    
     ···
  
  - 双向平方试探
    
    [Hash(key) + 1] % M
    
    [Hash(key) - 1] % M
    
    [Hash(key) + 4] % M
    
    [Hash(key) - 4] % M
  
  ### 应用
  
  - 桶排序
  
  ```python
  def bucketSort(nums):
      # 选择一个最大的数
      max_num = max(nums)
      # 创建一个元素全是0的列表, 当做桶
      bucket = [0]*(max_num+1)
      # 把所有元素放入桶中, 即把对应元素个数加一
      for i in nums:
          bucket[i] += 1
  
      # 存储排序好的元素
      sort_nums = []
      # 取出桶中的元素
      for j in range(len(bucket)):
          if bucket[j] != 0:
              for y in range(bucket[j]):
                  sort_nums.append(j)
  
      return sort_nums
  
  if __name__=='__main__':
      nums = [5,6,3,2,1,65,2,0,8,0]
      print(bucketsort(nums))
  ```