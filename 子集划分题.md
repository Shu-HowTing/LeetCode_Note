## 子集划分

> 这类题目的特征一般是将一个数组集合划分成两个(多个)子集部分，使得两个子集满足一定的条件：比如和相等或者均值相等。本质上是组合问题。使用回溯算法可以解决。但是有时候回溯算法时间复杂度会超时，会有一些低复杂度的解法。



- [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```bash
示例 1：

输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

```py
# 使用回溯解法
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        def backtrack(path, start):
            if sum(path) == target and len(path) < n:
                res.append(path[:])
                return
            if len(path) == n:
                return
            for i in range(start, n):
                if sum(path) + nums[i] > target:
                    break
                backtrack(path + [nums[i]], i+1)

        sum_num = sum(nums)
        if sum_num % 2:
            return False
    
        target = sum_num // 2
        nums.sort()
        res = []
        n =len(nums)

        backtrack([], 0)

        if len(res) > 0 :
            return True
        return False
```

```py
# 因为是选一些元素使得和满足target(target > 0)，所以也可以当成背包问题
class Solution:
    def canPartition(self, nums: List[int]) -> bool:

        sum_num = sum(nums)
        if sum_num % 2:
            return False
    
        target = sum_num // 2
  
        dp = [False] * (target+1)
        dp[0] = True
        # 0-1背包 
        for num in nums:
            for i in range(target, num-1, -1):
                dp[i] = dp[i-num] or dp[i]
  
        return dp[target]
```

[805. 数组的均值分割](https://leetcode.cn/problems/split-array-with-same-average/)

> 给定你一个整数数组 `nums`
> 
> 我们要将 `nums` 数组中的每个元素移动到 `A` 数组 或者 `B` 数组中，使得 `A` 数组和 `B` 数组不为空，并且 `average(A) == average(B)` 。
> 
> 如果可以完成则返回`true` ， 否则返回 `false`  。
> 
> **注意**: 对于数组 `arr` ,  `average(arr)` 是 `arr` 的所有元素的和除以 `arr` 长度。

```bash
示例 1:

输入: nums = [1,2,3,4,5,6,7,8]
输出: true
解释: 我们可以将数组分割为 [1,4,5,8] 和 [2,3,6,7], 他们的平均值都是4.5。
```

```py
# 通过转换nums，使得题目变成拆成 sum(A) = sum(B) = 0
class Solution:
    def splitArraySameAverage(self, nums: List[int]) -> bool:
        n = len(nums)
        # avg = sum(nums) / n
        # nums = [x-avg for x in nums]
        sum_num = sum(nums)
        nums = [x * n - sum_num for x in nums]
 
        def dfs(idx, path):
            if 0 < len(path) < n  and sum(path) == 0:
                return True
            if idx == n:
                return False
            A = dfs(idx+1,  path+[nums[idx]])
            B = dfs(idx+1,  path)
            return A or B
        flag = dfs(0, [])
        return flag
```



- [1755. 最接近目标值的子序列和](https://leetcode.cn/problems/closest-subsequence-sum/)









- [2035. 将数组分成两个数组并最小化数组和的差](https://leetcode.cn/problems/partition-array-into-two-arrays-to-minimize-sum-difference/)


